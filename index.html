<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>üèì VR Ping Pong</title>
  <meta name="description" content="VR Table Tennis for Oculus Quest">
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
  <style>
    #hud { position:fixed; top:20px; left:50%; transform:translateX(-50%); color:#fff; font:bold 24px Arial; background:rgba(0,0,0,0.6); padding:10px 25px; border-radius:10px; z-index:999; }
    #info { position:fixed; bottom:20px; left:50%; transform:translateX(-50%); color:#fff; font:14px Arial; background:rgba(0,0,0,0.7); padding:8px 15px; border-radius:8px; z-index:999; }
    #debug { position:fixed; top:60px; right:10px; color:#0f0; font:12px monospace; background:rgba(0,0,0,0.8); padding:10px; border-radius:5px; z-index:999; max-width:350px; white-space:pre-wrap; }
  </style>
</head>
<body>
  <div id="hud">0 ‚Äî 0</div>
  <div id="info">üéÆ TRIGGER/A/B = serve | GRIP = reset | THUMBSTICK = debug</div>
  <div id="debug">Debug: waiting for init...</div>

  <a-scene webxr="requiredFeatures: local-floor; optionalFeatures: hand-tracking">
    <a-sky color="#1a1a2e"></a-sky>
    <a-plane rotation="-90 0 0" width="20" height="20" color="#16213e"></a-plane>
    
    <a-light type="ambient" intensity="0.5"></a-light>
    <a-light type="directional" intensity="0.8" position="2 8 4"></a-light>

    <!-- Table -->
    <a-entity position="0 0.76 -1.5">
      <a-box width="1.525" height="0.03" depth="2.74" color="#1b5e20"></a-box>
      <a-box position="0 0.016 0" width="0.02" depth="2.74" height="0.002" color="#fff"></a-box>
      <a-box position="0 0.016 0" width="1.525" depth="0.02" height="0.002" color="#fff"></a-box>
      <a-box position="0 0.08 0" width="1.7" height="0.152" depth="0.01" color="#444"></a-box>
      <a-box position="0.65 -0.38 1.2" width="0.05" height="0.76" depth="0.05" color="#333"></a-box>
      <a-box position="-0.65 -0.38 1.2" width="0.05" height="0.76" depth="0.05" color="#333"></a-box>
      <a-box position="0.65 -0.38 -1.2" width="0.05" height="0.76" depth="0.05" color="#333"></a-box>
      <a-box position="-0.65 -0.38 -1.2" width="0.05" height="0.76" depth="0.05" color="#333"></a-box>
    </a-entity>

    <!-- Ball -->
    <a-sphere id="ball" radius="0.02" color="#ff9800" position="0 1.3 -0.3">
      <a-light type="point" color="#ff9800" intensity="0.4" distance="0.8"></a-light>
    </a-sphere>

    <!-- CPU Paddle -->
    <a-entity id="cpu-paddle" position="0 0.95 -2.87">
      <a-box width="0.15" height="0.16" depth="0.015" color="#1565c0"></a-box>
      <a-box width="0.025" height="0.10" depth="0.025" color="#8B4513" position="0 -0.13 0"></a-box>
    </a-entity>

    <!-- Desktop Paddle (hidden in VR) -->
    <a-entity id="desktop-paddle" position="0 1 0.2">
      <a-box width="0.15" height="0.16" depth="0.015" color="#c62828"></a-box>
      <a-box width="0.025" height="0.10" depth="0.025" color="#8B4513" position="0 -0.13 0"></a-box>
    </a-entity>

    <!-- VR Score display -->
    <a-text id="vr-score" value="0 ‚Äî 0" position="0 2.2 -1.5" align="center" color="#fff" width="5"></a-text>
    <a-text id="vr-msg" value="TRIGGER = Serve" position="0 1.9 -1.5" align="center" color="#4fc3f7" width="3"></a-text>
    <a-text id="vr-debug" value="" position="-0.8 2.5 -1.5" align="left" color="#0f0" width="2"></a-text>

    <!-- Player rig -->
    <a-entity id="rig" position="0 0 1">
      <a-camera></a-camera>
      
      <!-- Right hand with paddle -->
      <a-entity id="rhand" 
                oculus-touch-controls="hand: right" 
                laser-controls="hand: right">
        <!-- Paddle attached to controller -->
        <a-entity id="vr-paddle" position="0 0 -0.05" rotation="-45 0 0">
          <a-box width="0.15" height="0.16" depth="0.015" color="#c62828"></a-box>
          <a-box width="0.025" height="0.10" depth="0.025" color="#8B4513" position="0 -0.13 0"></a-box>
        </a-entity>
        <!-- Debug sphere at controller position -->
        <a-sphere id="controller-marker" radius="0.02" color="#00ff00" position="0 0 0"></a-sphere>
      </a-entity>
      
      <!-- Left hand -->
      <a-entity id="lhand" oculus-touch-controls="hand: left"></a-entity>
    </a-entity>
  </a-scene>

  <script>
    'use strict';
    
    // ============ GAME STATE ============
    let myScore = 0, cpuScore = 0;
    let ballVel = { x: 0, y: 0, z: 0 };
    let playing = false;
    let lastHit = '';
    let lastHitTime = 0;
    let inVR = false;
    let controllerConnected = false;
    let initialized = false;
    
    // ============ PHYSICS ============
    const GRAVITY = -9.81;
    const TABLE = {
      top: 0.775,
      z: -1.5,
      halfWidth: 0.76,
      minZ: -2.87,
      maxZ: -0.13,
      netHeight: 0.152
    };
    
    // ============ AI CONFIG (AGGRESSIVE) ============
    const AI = {
      reactionDelay: 0.08,    // Very fast reaction
      speed: 6.0,             // Fast movement
      accuracy: 0.92,         // High accuracy
      returnSpeed: 5.5,       // Strong returns
      predictAhead: true
    };
    let aiReactionTimer = 0;
    let aiTarget = { x: 0, y: 0.95 };
    
    // ============ PADDLE TRACKING ============
    let lastPaddlePos = new THREE.Vector3();
    let paddleVelocity = new THREE.Vector3();
    let lastFrameTime = 0;
    
    // ============ ELEMENTS ============
    let ball, cpuPaddle, desktopPaddle, vrPaddle, rhand, scene;
    
    // ============ DEBUG ============
    function log(msg) {
      const dbg = document.getElementById('debug');
      if (dbg) {
        const time = new Date().toLocaleTimeString();
        dbg.textContent = `[${time}]\n${msg}\n\n` + dbg.textContent.slice(0, 800);
      }
      // Also show in VR
      const vrDbg = document.getElementById('vr-debug');
      if (vrDbg) vrDbg.setAttribute('value', msg.slice(0, 100));
    }
    
    // ============ INITIALIZATION ============
    function init() {
      scene = document.querySelector('a-scene');
      if (!scene) { setTimeout(init, 100); return; }
      
      if (scene.hasLoaded) {
        onSceneLoaded();
      } else {
        scene.addEventListener('loaded', onSceneLoaded);
      }
    }
    
    function onSceneLoaded() {
      if (initialized) return;
      
      ball = document.getElementById('ball');
      cpuPaddle = document.getElementById('cpu-paddle');
      desktopPaddle = document.getElementById('desktop-paddle');
      vrPaddle = document.getElementById('vr-paddle');
      rhand = document.getElementById('rhand');
      
      if (!ball || !cpuPaddle || !vrPaddle || !rhand) {
        log('Waiting for elements...');
        setTimeout(onSceneLoaded, 100);
        return;
      }
      
      initialized = true;
      log('Scene loaded!\nWaiting for VR...');
      
      // VR state
      scene.addEventListener('enter-vr', () => {
        inVR = true;
        if (desktopPaddle) desktopPaddle.setAttribute('visible', false);
        log('ENTERED VR MODE');
      });
      
      scene.addEventListener('exit-vr', () => {
        inVR = false;
        if (desktopPaddle) desktopPaddle.setAttribute('visible', true);
        log('Exited VR');
      });
      
      // Controller events - multiple ways to trigger serve
      rhand.addEventListener('controllerconnected', (e) => {
        controllerConnected = true;
        log(`Controller connected!\n${e.detail.name}`);
      });
      
      // All possible button events for serve
      const serveEvents = [
        'triggerdown', 'triggerup',
        'gripdown', 
        'abuttondown', 'bbuttondown',
        'xbuttondown', 'ybuttondown',
        'thumbstickdown'
      ];
      
      serveEvents.forEach(evt => {
        rhand.addEventListener(evt, (e) => {
          log(`Button: ${evt}`);
          if (evt === 'gripdown') {
            // Grip = RESET game (clears "already playing" state)
            resetGame();
          } else if (evt === 'thumbstickdown') {
            // Thumbstick = toggle debug
            const dbg = document.getElementById('debug');
            dbg.style.display = dbg.style.display === 'none' ? 'block' : 'none';
          } else if (evt.includes('down')) {
            serve();
          }
        });
      });
      
      // Left hand can also serve
      const lhand = document.getElementById('lhand');
      if (lhand) {
        lhand.addEventListener('triggerdown', serve);
        lhand.addEventListener('gripdown', serve);
      }
      
      // Desktop controls
      document.addEventListener('keydown', e => {
        if (e.code === 'Space') serve();
        if (e.code === 'KeyR') resetGame(); // R = reset
      });
      // NO automatic click-to-serve - it interferes with VR
      
      document.addEventListener('mousemove', e => {
        if (!inVR && desktopPaddle && desktopPaddle.object3D) {
          const x = (e.clientX / window.innerWidth - 0.5) * 1.4;
          const y = 0.8 + (1 - e.clientY / window.innerHeight) * 0.5;
          desktopPaddle.object3D.position.set(x, y, 0.2);
        }
      });
      
      lastFrameTime = performance.now();
      requestAnimationFrame(gameLoop);
      
      log('Init complete!\nPress TRIGGER to serve');
    }
    
    // ============ GET PADDLE POSITION ============
    function getPaddleWorldPos() {
      let paddle = inVR ? vrPaddle : desktopPaddle;
      if (!paddle || !paddle.object3D) {
        log('No paddle!');
        return null;
      }
      
      const pos = new THREE.Vector3();
      
      if (inVR) {
        // Force update the entire hierarchy
        if (rhand && rhand.object3D) {
          rhand.object3D.updateMatrixWorld(true);
        }
        paddle.object3D.getWorldPosition(pos);
      } else {
        pos.copy(paddle.object3D.position);
      }
      
      return pos;
    }
    
    // ============ SERVE ============
    function serve() {
      if (playing) {
        log('Already playing');
        return;
      }
      
      log('SERVE!');
      
      playing = true;
      lastHit = 'player';
      lastHitTime = performance.now();
      
      // Get paddle position for serve origin
      let servePos = getPaddleWorldPos();
      
      // Fallback if paddle position fails
      if (!servePos || servePos.length() < 0.01) {
        servePos = new THREE.Vector3(0, 1.2, 0.5);
        log('Using fallback serve pos');
      }
      
      log(`Serve from: ${servePos.x.toFixed(2)}, ${servePos.y.toFixed(2)}, ${servePos.z.toFixed(2)}`);
      
      // Position ball above paddle
      ball.object3D.position.set(
        servePos.x,
        servePos.y + 0.3,
        servePos.z - 0.2
      );
      
      // Launch towards opponent
      ballVel = {
        x: (Math.random() - 0.5) * 1.0,
        y: 1.5,
        z: -5.0
      };
      
      // Reset AI
      aiReactionTimer = 0;
      aiTarget.x = 0;
      
      setMessage('');
      triggerHaptic(0.5, 100);
    }
    
    // ============ HAPTICS ============
    function triggerHaptic(intensity, duration) {
      if (!inVR || !rhand) return;
      try {
        const components = rhand.components;
        const tc = components['tracked-controls'] || components['oculus-touch-controls'];
        if (tc && tc.controller && tc.controller.gamepad) {
          const gp = tc.controller.gamepad;
          if (gp.hapticActuators && gp.hapticActuators[0]) {
            gp.hapticActuators[0].pulse(intensity, duration);
          }
        }
      } catch (e) { /* ignore */ }
    }
    
    // ============ BALL PHYSICS ============
    function updateBall(dt) {
      if (!ball || !ball.object3D) return;
      
      const pos = ball.object3D.position;
      
      // Gravity
      ballVel.y += GRAVITY * dt;
      
      // Air resistance
      ballVel.x *= 0.998;
      ballVel.z *= 0.998;
      
      // Move
      pos.x += ballVel.x * dt;
      pos.y += ballVel.y * dt;
      pos.z += ballVel.z * dt;
      
      // Table bounce
      if (pos.y < TABLE.top + 0.02 && 
          pos.z > TABLE.minZ && pos.z < TABLE.maxZ && 
          Math.abs(pos.x) < TABLE.halfWidth) {
        pos.y = TABLE.top + 0.02;
        ballVel.y = Math.abs(ballVel.y) * 0.8;
        if (Math.abs(ballVel.y) < 0.5) ballVel.y = 0.5;
      }
      
      // Net
      if (Math.abs(pos.z - TABLE.z) < 0.03 && 
          pos.y < TABLE.top + TABLE.netHeight && 
          pos.y > TABLE.top - 0.05) {
        ballVel.z *= -0.3;
        pos.z = TABLE.z + (ballVel.z > 0 ? 0.05 : -0.05);
        log('Net!');
      }
      
      // Out of bounds
      if (pos.y < 0.3 || Math.abs(pos.x) > 2 || pos.z > 2 || pos.z < -4.5) {
        const winner = pos.z > TABLE.z ? 'cpu' : 'player';
        scored(winner);
      }
    }
    
    // ============ AI (HARDER) ============
    function updateAI(dt) {
      if (!cpuPaddle || !cpuPaddle.object3D || !ball || !ball.object3D) return;
      
      const bp = ball.object3D.position;
      const cp = cpuPaddle.object3D.position;
      
      // Ball approaching?
      const approaching = ballVel.z < -0.5;
      
      if (approaching && bp.z < -0.5) {
        aiReactionTimer += dt;
        
        if (aiReactionTimer > AI.reactionDelay) {
          // Predict where ball will be at CPU's z position
          const timeToArrive = (cp.z - bp.z) / ballVel.z;
          let predictX = bp.x + ballVel.x * timeToArrive;
          let predictY = bp.y + ballVel.y * timeToArrive + 0.5 * GRAVITY * timeToArrive * timeToArrive;
          
          // Account for table bounces
          if (predictY < TABLE.top && bp.z > TABLE.minZ) {
            predictY = TABLE.top + 0.15; // Approximate post-bounce height
          }
          
          // Add small random error
          predictX += (Math.random() - 0.5) * (1 - AI.accuracy) * 0.3;
          
          aiTarget.x = Math.max(-0.6, Math.min(0.6, predictX));
          aiTarget.y = Math.max(0.85, Math.min(1.15, predictY));
        }
        
        // Move towards target
        const dx = aiTarget.x - cp.x;
        const dy = aiTarget.y - cp.y;
        const moveSpeed = AI.speed * dt;
        
        if (Math.abs(dx) > 0.01) {
          cp.x += Math.sign(dx) * Math.min(moveSpeed, Math.abs(dx));
        }
        if (Math.abs(dy) > 0.01) {
          cp.y += Math.sign(dy) * Math.min(moveSpeed * 0.7, Math.abs(dy));
        }
        
      } else {
        // Return to center
        cp.x += (0 - cp.x) * 3 * dt;
        cp.y += (0.95 - cp.y) * 3 * dt;
        aiReactionTimer = 0;
      }
    }
    
    // ============ COLLISION ============
    const HIT_COOLDOWN = 200;
    const HIT_RADIUS = 0.18;
    const HIT_RADIUS_SQ = HIT_RADIUS * HIT_RADIUS;
    
    function updatePaddleTracking(dt) {
      const pos = getPaddleWorldPos();
      if (!pos) return;
      
      if (dt > 0.001) {
        paddleVelocity.x = (pos.x - lastPaddlePos.x) / dt;
        paddleVelocity.y = (pos.y - lastPaddlePos.y) / dt;
        paddleVelocity.z = (pos.z - lastPaddlePos.z) / dt;
      }
      
      lastPaddlePos.copy(pos);
    }
    
    function checkCollisions(now) {
      if (!ball || !ball.object3D) return;
      if (now - lastHitTime < HIT_COOLDOWN) return;
      
      const bp = ball.object3D.position;
      
      // Player paddle
      if (lastHit !== 'player') {
        const pp = getPaddleWorldPos();
        if (pp) {
          const dist = bp.distanceToSquared(pp);
          if (dist < HIT_RADIUS_SQ) {
            hitBall('player', pp);
          }
        }
      }
      
      // CPU paddle
      if (lastHit !== 'cpu' && cpuPaddle && cpuPaddle.object3D) {
        const cp = cpuPaddle.object3D.position;
        const dist = Math.pow(bp.x - cp.x, 2) + Math.pow(bp.y - cp.y, 2) + Math.pow(bp.z - cp.z, 2);
        if (dist < HIT_RADIUS_SQ) {
          hitBall('cpu', cp);
        }
      }
    }
    
    function hitBall(who, paddlePos) {
      lastHit = who;
      lastHitTime = performance.now();
      
      const bp = ball.object3D.position;
      const dir = who === 'player' ? -1 : 1;
      
      // Offset from paddle center affects angle
      const offsetX = (bp.x - paddlePos.x) / HIT_RADIUS;
      const offsetY = (bp.y - paddlePos.y) / HIT_RADIUS;
      
      let speed = 5.0;
      
      if (who === 'player') {
        // Add paddle velocity
        speed += Math.min(3, Math.abs(paddleVelocity.z) * 0.3);
        triggerHaptic(0.7, 100);
        log('HIT!');
      } else {
        // CPU hits harder
        speed = AI.returnSpeed + Math.random() * 1.5;
      }
      
      ballVel = {
        x: offsetX * 2 + (who === 'player' ? paddleVelocity.x * 0.1 : (Math.random() - 0.5) * 2),
        y: 1.2 + offsetY * 0.5 + Math.random() * 0.4,
        z: dir * speed
      };
      
      // Visual flash
      ball.setAttribute('color', who === 'player' ? '#4caf50' : '#f44336');
      setTimeout(() => ball.setAttribute('color', '#ff9800'), 100);
    }
    
    // ============ SCORING ============
    function scored(winner) {
      playing = false;
      
      if (winner === 'player') myScore++;
      else cpuScore++;
      
      updateScore();
      resetBall();
      
      log(`Point: ${winner}`);
      
      if (myScore >= 11 || cpuScore >= 11) {
        const won = myScore > cpuScore;
        setMessage(won ? 'üèÜ YOU WIN!' : 'üò¢ CPU WINS');
        triggerHaptic(won ? 1.0 : 0.2, 300);
        
        setTimeout(() => {
          myScore = cpuScore = 0;
          updateScore();
          setMessage('TRIGGER = Serve');
        }, 3000);
      } else {
        setMessage('TRIGGER = Serve');
        triggerHaptic(winner === 'player' ? 0.6 : 0.2, 100);
      }
    }
    
    function resetBall() {
      if (!ball || !ball.object3D) return;
      ball.object3D.position.set(0, 1.3, -0.3);
      ballVel = { x: 0, y: 0, z: 0 };
      lastHit = '';
    }
    
    function resetGame() {
      playing = false;
      myScore = 0;
      cpuScore = 0;
      resetBall();
      updateScore();
      setMessage('TRIGGER = Serve');
      log('GAME RESET');
    }
    
    // ============ UI ============
    function updateScore() {
      const txt = `${myScore} ‚Äî ${cpuScore}`;
      document.getElementById('hud').textContent = txt;
      const vs = document.getElementById('vr-score');
      if (vs) vs.setAttribute('value', txt);
    }
    
    function setMessage(msg) {
      const vm = document.getElementById('vr-msg');
      if (vm) vm.setAttribute('value', msg);
    }
    
    // ============ GAME LOOP ============
    function gameLoop(timestamp) {
      const dt = Math.min((timestamp - lastFrameTime) / 1000, 0.05);
      lastFrameTime = timestamp;
      
      if (initialized) {
        updatePaddleTracking(dt);
        
        if (playing) {
          updateBall(dt);
          updateAI(dt);
          checkCollisions(timestamp);
        }
        
        // Continuous debug info in VR
        if (inVR) {
          const pp = getPaddleWorldPos();
          if (pp) {
            const vrDbg = document.getElementById('vr-debug');
            if (vrDbg) {
              vrDbg.setAttribute('value', 
                `Paddle: ${pp.x.toFixed(2)}, ${pp.y.toFixed(2)}, ${pp.z.toFixed(2)}\n` +
                `inVR: ${inVR} ctrl: ${controllerConnected}`
              );
            }
          }
        }
      }
      
      requestAnimationFrame(gameLoop);
    }
    
    // ============ START ============
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', init);
    } else {
      init();
    }
  </script>
</body>
</html>
