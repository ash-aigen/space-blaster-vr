<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>üèì VR Ping Pong</title>
  <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
  <style>
    #hud { position:fixed; top:20px; left:50%; transform:translateX(-50%); color:#fff; font:bold 28px Arial; background:rgba(0,0,0,0.7); padding:12px 30px; border-radius:10px; z-index:999; }
  </style>
</head>
<body>
  <div id="hud">0 ‚Äî 0</div>

  <a-scene webxr="requiredFeatures: local-floor">
    <a-sky color="#1a1a2e"></a-sky>
    <a-plane rotation="-90 0 0" width="20" height="20" color="#16213e"></a-plane>
    <a-light type="ambient" intensity="0.5"></a-light>
    <a-light type="directional" intensity="0.7" position="2 5 3"></a-light>

    <!-- Table -->
    <a-entity id="table" position="0 0.76 -1.5">
      <a-box width="1.525" height="0.03" depth="2.74" color="#1b5e20"></a-box>
      <!-- Center line -->
      <a-box position="0 0.016 0" width="0.02" depth="2.74" height="0.003" color="#fff"></a-box>
      <!-- End lines -->
      <a-box position="0 0.016 1.37" width="1.525" depth="0.02" height="0.003" color="#fff"></a-box>
      <a-box position="0 0.016 -1.37" width="1.525" depth="0.02" height="0.003" color="#fff"></a-box>
      <!-- Net -->
      <a-box position="0 0.08 0" width="1.6" height="0.15" depth="0.02" color="#333" opacity="0.8"></a-box>
      <!-- Legs -->
      <a-box position="0.7 -0.38 1.2" width="0.05" height="0.76" depth="0.05" color="#444"></a-box>
      <a-box position="-0.7 -0.38 1.2" width="0.05" height="0.76" depth="0.05" color="#444"></a-box>
      <a-box position="0.7 -0.38 -1.2" width="0.05" height="0.76" depth="0.05" color="#444"></a-box>
      <a-box position="-0.7 -0.38 -1.2" width="0.05" height="0.76" depth="0.05" color="#444"></a-box>
    </a-entity>

    <!-- Ball -->
    <a-sphere id="ball" radius="0.02" color="#ff9800" position="0 1.2 -0.3">
      <a-light type="point" color="#ff9800" intensity="0.3" distance="0.5"></a-light>
    </a-sphere>

    <!-- CPU Paddle -->
    <a-entity id="cpu-paddle" position="0 0.95 -2.8">
      <a-box width="0.15" height="0.15" depth="0.015" color="#1565c0"></a-box>
      <a-cylinder radius="0.012" height="0.1" color="#8B4513" position="0 -0.12 0"></a-cylinder>
    </a-entity>

    <!-- Player Paddle -->
    <a-entity id="player-paddle" position="0 1 0">
      <a-box width="0.15" height="0.15" depth="0.015" color="#c62828"></a-box>
      <a-cylinder radius="0.012" height="0.1" color="#8B4513" position="0 -0.12 0"></a-cylinder>
    </a-entity>

    <!-- VR UI -->
    <a-text id="vr-score" value="0 ‚Äî 0" position="0 2.2 -1.5" align="center" color="#fff" width="6"></a-text>
    <a-text id="vr-msg" value="Press any button to serve!" position="0 1.9 -1.5" align="center" color="#4fc3f7" width="3"></a-text>

    <!-- Player camera -->
    <a-entity position="0 0 1">
      <a-camera></a-camera>
    </a-entity>
  </a-scene>

  <script>
    // ===== STATE =====
    let myScore = 0, cpuScore = 0;
    let ballVel = { x: 0, y: 0, z: 0 };
    let playing = false;
    let lastHit = '';
    let lastHitTime = 0;
    let inVR = false;
    let xrSession = null, xrRefSpace = null, rightController = null;
    let controllerPos = new THREE.Vector3(0, 1, 0.5);
    let lastControllerPos = new THREE.Vector3(0, 1, 0.5);
    let controllerVel = new THREE.Vector3();
    let btnWasPressed = false;
    
    // ===== CONSTANTS =====
    const GRAVITY = -9.81;
    const TABLE_Y = 0.775;
    const TABLE_Z = -1.5;
    const TABLE_HALF_W = 0.76;
    const TABLE_MIN_Z = -2.87;
    const TABLE_MAX_Z = -0.13;
    const NET_HEIGHT = 0.15;
    const HIT_RADIUS = 0.15;
    const HIT_COOLDOWN = 150;
    
    // ===== ELEMENTS =====
    let scene, renderer, ball, cpuPaddle, playerPaddle;
    
    // ===== INIT =====
    function init() {
      scene = document.querySelector('a-scene');
      if (!scene?.hasLoaded) {
        scene?.addEventListener('loaded', init);
        setTimeout(init, 100);
        return;
      }
      
      ball = document.getElementById('ball');
      cpuPaddle = document.getElementById('cpu-paddle');
      playerPaddle = document.getElementById('player-paddle');
      renderer = scene.renderer;
      
      scene.addEventListener('enter-vr', onEnterVR);
      scene.addEventListener('exit-vr', () => { inVR = false; });
      
      // Desktop controls
      document.addEventListener('click', serve);
      document.addEventListener('mousemove', e => {
        if (inVR || !playerPaddle) return;
        const x = (e.clientX / window.innerWidth - 0.5) * 1.4;
        const y = 0.7 + (1 - e.clientY / window.innerHeight) * 0.5;
        playerPaddle.object3D.position.set(x, y, 0.1);
        controllerPos.set(x, y, 0.1);
      });
      
      // Start game loop
      scene.setAttribute('game-loop', '');
    }
    
    // ===== VR SETUP =====
    function onEnterVR() {
      inVR = true;
      xrSession = renderer.xr?.getSession?.();
      if (!xrSession) return;
      
      xrSession.requestReferenceSpace('local-floor')
        .then(s => { xrRefSpace = s; })
        .catch(() => xrSession.requestReferenceSpace('local').then(s => { xrRefSpace = s; }));
      
      function findController() {
        for (const src of xrSession.inputSources) {
          if (src.handedness === 'right' && src.gripSpace) {
            rightController = src;
            break;
          }
        }
      }
      findController();
      xrSession.addEventListener('inputsourceschange', findController);
    }
    
    // ===== SERVE =====
    function serve() {
      if (playing) return;
      
      playing = true;
      lastHit = 'player';
      lastHitTime = performance.now();
      
      // Ball starts above paddle
      const pos = controllerPos.clone();
      ball.object3D.position.set(pos.x, pos.y + 0.15, pos.z - 0.1);
      
      // Serve towards opponent
      ballVel = {
        x: (Math.random() - 0.5) * 1,
        y: 1.5,
        z: -5
      };
      
      setMessage('');
    }
    
    // ===== BALL PHYSICS =====
    function updateBall(dt) {
      if (!playing || !ball) return;
      
      const pos = ball.object3D.position;
      
      // Gravity
      ballVel.y += GRAVITY * dt;
      
      // Move
      pos.x += ballVel.x * dt;
      pos.y += ballVel.y * dt;
      pos.z += ballVel.z * dt;
      
      // Table bounce
      if (pos.y < TABLE_Y + 0.02 && 
          pos.z > TABLE_MIN_Z && pos.z < TABLE_MAX_Z && 
          Math.abs(pos.x) < TABLE_HALF_W) {
        pos.y = TABLE_Y + 0.02;
        ballVel.y = Math.abs(ballVel.y) * 0.8;
      }
      
      // Net collision
      if (Math.abs(pos.z - TABLE_Z) < 0.03 && pos.y < TABLE_Y + NET_HEIGHT) {
        ballVel.z *= -0.5;
        pos.z = TABLE_Z + (ballVel.z > 0 ? 0.04 : -0.04);
      }
      
      // Out of bounds
      if (pos.y < 0.2 || Math.abs(pos.x) > 2 || pos.z > 2 || pos.z < -4) {
        score(pos.z > TABLE_Z ? 'cpu' : 'player');
      }
    }
    
    // ===== AI =====
    function updateAI(dt) {
      if (!cpuPaddle || !ball) return;
      
      const bp = ball.object3D.position;
      const cp = cpuPaddle.object3D.position;
      
      // Track ball when coming towards AI
      if (ballVel.z < -1) {
        const targetX = Math.max(-0.6, Math.min(0.6, bp.x));
        cp.x += (targetX - cp.x) * 5 * dt;
        
        // Adjust height
        const targetY = Math.max(0.85, Math.min(1.1, bp.y));
        cp.y += (targetY - cp.y) * 4 * dt;
      } else {
        // Return to center
        cp.x += (0 - cp.x) * 3 * dt;
        cp.y += (0.95 - cp.y) * 3 * dt;
      }
    }
    
    // ===== COLLISION =====
    function checkCollisions(now) {
      if (!playing || !ball) return;
      if (now - lastHitTime < HIT_COOLDOWN) return;
      
      const bp = ball.object3D.position;
      
      // Player paddle
      if (lastHit !== 'player') {
        const dist = bp.distanceTo(controllerPos);
        if (dist < HIT_RADIUS) {
          hitBall('player');
        }
      }
      
      // CPU paddle
      if (lastHit !== 'cpu' && cpuPaddle) {
        const cp = cpuPaddle.object3D.position;
        const dist = Math.sqrt(
          Math.pow(bp.x - cp.x, 2) + 
          Math.pow(bp.y - cp.y, 2) + 
          Math.pow(bp.z - cp.z, 2)
        );
        if (dist < HIT_RADIUS) {
          hitBall('cpu');
        }
      }
    }
    
    function hitBall(who) {
      lastHit = who;
      lastHitTime = performance.now();
      
      const dir = who === 'player' ? -1 : 1;
      let speed = 5;
      
      if (who === 'player') {
        // Add paddle velocity for more powerful shots
        speed += Math.min(3, controllerVel.length() * 0.3);
      }
      
      ballVel = {
        x: (Math.random() - 0.5) * 2 + (who === 'player' ? controllerVel.x * 0.2 : 0),
        y: 1 + Math.random() * 0.5,
        z: dir * speed
      };
      
      // Flash color
      ball.setAttribute('color', who === 'player' ? '#4caf50' : '#f44336');
      setTimeout(() => ball.setAttribute('color', '#ff9800'), 100);
    }
    
    // ===== SCORING =====
    function score(winner) {
      playing = false;
      
      if (winner === 'player') myScore++;
      else cpuScore++;
      
      updateScoreDisplay();
      resetBall();
      
      if (myScore >= 11 || cpuScore >= 11) {
        setMessage(myScore > cpuScore ? 'üèÜ YOU WIN!' : 'üò¢ CPU WINS');
        setTimeout(() => {
          myScore = cpuScore = 0;
          updateScoreDisplay();
          setMessage('Press to serve!');
        }, 3000);
      } else {
        setMessage('Press to serve!');
      }
    }
    
    function resetBall() {
      ball.object3D.position.set(0, 1.2, -0.3);
      ballVel = { x: 0, y: 0, z: 0 };
      lastHit = '';
    }
    
    function updateScoreDisplay() {
      const txt = `${myScore} ‚Äî ${cpuScore}`;
      document.getElementById('hud').textContent = txt;
      document.getElementById('vr-score')?.setAttribute('value', txt);
    }
    
    function setMessage(msg) {
      document.getElementById('vr-msg')?.setAttribute('value', msg);
    }
    
    // ===== GAME LOOP =====
    AFRAME.registerComponent('game-loop', {
      tick: function(time, delta) {
        const dt = Math.min(delta / 1000, 0.05);
        const now = performance.now();
        
        // Update controller position (VR)
        if (inVR && xrSession && xrRefSpace && rightController) {
          const frame = renderer.xr?.getFrame?.();
          if (frame) {
            try {
              const pose = frame.getPose(rightController.gripSpace, xrRefSpace);
              if (pose) {
                const p = pose.transform.position;
                const q = pose.transform.orientation;
                
                lastControllerPos.copy(controllerPos);
                controllerPos.set(p.x, p.y, p.z);
                
                // Calculate velocity
                if (dt > 0.001) {
                  controllerVel.subVectors(controllerPos, lastControllerPos).divideScalar(dt);
                }
                
                // Update paddle visual
                if (playerPaddle?.object3D) {
                  playerPaddle.object3D.position.copy(controllerPos);
                  playerPaddle.object3D.quaternion.set(q.x, q.y, q.z, q.w);
                }
              }
            } catch(e) {}
          }
          
          // Check gamepad buttons for serve
          if (rightController.gamepad && !playing) {
            const pressed = rightController.gamepad.buttons.some(b => b.pressed);
            if (pressed && !btnWasPressed) {
              serve();
            }
            btnWasPressed = pressed;
          }
        }
        
        // Game updates
        updateBall(dt);
        updateAI(dt);
        checkCollisions(now);
      }
    });
    
    // ===== START =====
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', init);
    } else {
      init();
    }
  </script>
</body>
</html>
